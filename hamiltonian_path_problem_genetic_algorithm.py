# -*- coding: utf-8 -*-
"""Hamiltonian_Path_Problem_Genetic_Algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b4nloppsr1KZFNHjenHMdyfM9_oZ_Q-G

# Genetic Algorithm Assignment Andras Szivolics T00212479

##    **4x4 Hamiltonian Path Problem Genetic Algorithm**

*   A mapping genetic algorithm that starts from a point on a square graph and must end on another defined point after landing on every other space once. The algorithm is not allowed to go over a space it has been on before other than the starting point. What are the paths the algorithm could take to get the soultion/s that fit with the rules. For this example the graph will be a simple 4x4 square.

*   Since there are many more paths that are incorrect than correct, and the shape of the graph could drastically alter the computational complexity of the amount of paths that are correct, it is approriate to apply the genetic algorithm to this problem even if for a simple 4x4 square to see if it can get the correct answers. With a bit of change to the code it would also be able to traverse a more complex graph where the answers are not as straightforward or if there are any correct answers at all.

# The problem and the cost function   **(~20%)**
"""

import random
import numpy as np
from copy import deepcopy

def graph_completion(chromosome):
 cost = 1
 for x in range(0, 17, 1):
  if chromosome[x] == 0:
   cost = cost + 1
 for x in range(0, 15, 1):
   if(chromosome[x] != 0 and (chromosome[16] == 16)):
     cost = 0
     return cost

 return cost

class problem:
  def __init__(self):
    self.cost_function = graph_completion

"""# The Individual **(~30%)**


*   Chromosome
*   Crossover
*   Mutation


"""

import random
import numpy as np
from copy import deepcopy

class individual:
 chromosone = None


 def border_check(index):
       down = 4
       left = -1
       right = 1
       up = -4
       direction_list = [down, left, right, up]
       direction = random.choice(direction_list)
       possibleDestination = index+direction

       if (possibleDestination < 1) or (possibleDestination >= 17) or (((index % 4) == 1) and (direction == left)) or (((index % 4) == 0) and (direction == right)):
          correct_direction = individual.border_check(index)
          return correct_direction

       else:
         return possibleDestination

 def create_initial_chromosomes():
    chromosome = np.zeros(0, dtype = int)
    chromosome = np.insert(chromosome, 0, 1)
    cost = 0
    graph_array = np.array([False, False, False, False,
                                                False, False, False, False,
                                                False, False, False, False,
                                                False, False, False, False])

    for x in range(1, 17, 1):
     ideal = individual.border_check(chromosome[x-1])
     if (graph_array[ideal-1] == False):
      chromosome = np.insert(chromosome, x, ideal)
      graph_array[chromosome[x]-1] = True;

     else:
        while(x != 17):
         chromosome = np.insert(chromosome, x, 0)
         x = x+1
        break

    return chromosome


 def __init__(self, prob):
   self.chromosome = individual.create_initial_chromosomes()
   self.cost = prob.cost_function(self.chromosome)



 def mutate_chromosome(chromosome, start_mutation):
  mutated_chromosome = np.zeros(0, dtype = int)
  mutated_chromosome = np.insert(mutated_chromosome, 0, 1)
  graph_array = np.array([False, False, False, False,
                                             False, False, False, False,
                                             False, False, False, False,
                                             False, False, False, False])
  for x in range(1, start_mutation+1, 1):
    mutated_chromosome = np.insert(mutated_chromosome, x, chromosome[x])
    graph_array[chromosome[x]-1] = True;

  for x in range(start_mutation+1, 17, 1):
     ideal = individual.border_check(mutated_chromosome[x-1])
     if (graph_array[ideal-1] == False):
      mutated_chromosome = np.insert(mutated_chromosome, x, ideal)
      graph_array[mutated_chromosome[x]-1] = True;

     else:
        while(x != 17):
         mutated_chromosome = np.insert(mutated_chromosome, x, 0)
         x = x+1
        break

  return mutated_chromosome


 def potentially_mutate(chromosome):
  mutation_rate = 0.02
  for x in range(1, 17, 1):
   if(np.random.uniform() < mutation_rate and (chromosome.chromosome[x] != 0)):
    mutated_chromosome = individual.mutate_chromosome(chromosome.chromosome, x)
    chromosome.chromosome = mutated_chromosome
    break

  return chromosome



 def child1_crossover(self, parent2):
  child1 = deepcopy(self)
  parent1 = deepcopy(self)
  child1 = np.zeros(0, dtype = int)
  child1 = np.insert(child1, 0, 1)
  for x in reversed(range(16)) :
   for i in reversed(range(16)) :
    if(parent1[x]  == parent2[i] and (parent1[x] != 0)):
      for j in range(1, x+1, 1):
       child1 = np.insert(child1, j, parent1[j])
      a = x
      for y in range(i+1, 17, 1):
       for z in reversed(range(1, x)):
        if(parent2[y] == parent1[z] and (parent2[y] != 0)):
          return child1
        if(parent2[y] == 0):
         return child1
       child1 = np.insert(child1, a+1, parent2[y])
       a = a + 1
      return child1


 def child2_crossover(self, parent2):
  child2 = deepcopy(parent2)
  parent1 = deepcopy(self)
  child2 = np.zeros(0, dtype = int)
  child2 = np.insert(child2, 0, 1)
  for x in reversed(range(17)) :
   for i in reversed(range(17)) :
    if(parent1[i] == parent2[x] and (parent2[x] != 0)):
      for j in range(1, x+1, 1):
       child2 = np.insert(child2, j, parent2[j])
      a = x
      for y in range(i+1, 17, 1):
       for z in reversed(range(1, x)):
        if(parent1[y] == parent2[z] and (parent1[y] != 0)):
          return child2
        if(parent1[y] == 0):
         return child2
       child2 = np.insert(child2, a+1, parent1[y])
       a = a + 1
      return child2


 def crossover(self, parent2):
  parent1 = deepcopy(self)
  child1 = deepcopy(self)
  child2 = deepcopy(parent2)
  childtemp1 = individual.child1_crossover(parent1.chromosome, parent2.chromosome)
  childtemp2 = individual.child2_crossover(parent1.chromosome, parent2.chromosome)
  child1.chromosome = childtemp1
  child2.chromosome = childtemp2
  child1_cost = 0
  child2_cost = 0
  parent1_cost = 0
  parent2_cost = 0
  x = 0

  while(x < 16):
   if(parent1.chromosome[x] == 0):
    parent1_cost = parent1_cost + 1

   if(parent2.chromosome[x] == 0):
    parent2_cost = parent2_cost + 1

   x = x + 1

  for b in range(1, 16, 1):
   if(child1.chromosome[b] == child1.chromosome[-1] or (child1.chromosome[b] == 0)):
    child1.chromosome = np.insert(child1.chromosome, b+1, 0)
    child1_cost = child1_cost + 1
   if(len(child1.chromosome) > 16):
     break

  for b in range(1, 16, 1):
   if(child2.chromosome[b] == child2.chromosome[-1] or (child2.chromosome[b] == 0)):
    child2.chromosome = np.insert(child2.chromosome, b+1, 0)
    child2_cost = child2_cost + 1
   if(len(child2.chromosome) > 16):
     break

  if(parent1_cost < child1_cost):
   child1 = parent1

  if(parent2_cost < child2_cost):
   child2 = parent2

  return child1, child2

"""## Discussion and justification on the approaches taken for the above

---

*  The create_initial_chromosomes method creates the first generation of chromosomes and tests if the path they took is a legal path. It does this by creating a chromosome with an initial value of 1 at the start, this is because all paths in this problem have to start at position 1. It then goes through the check_border method which takes the value within a chromosome that is currently in the for loop, and gives it a legal direction to take. The value returned by check_border is then checked again if the potential path has been crossed before by checking if that position on the graph is set to true. If it hasn't, the chromosome at the specific position of it's array is set to the validated value, and the previous position it was in on the graph is set to true to mark it as being crossed once. When it inevitably reaches a dead end, it enters a while loop where the remainder of the chromosome gets filled with zeros which deermines it's cost. On top of that chromosomes will always have at least a cost of 1 if they do not end with 16. This is to filter through all the chromosomes that do map every position on the graph but just don't end in 16.

* For the mutation, there are the potentially_mutate and the mutate_chromosome methods. Every chromosome will be put through the potentially_mutate method which cycles through each position of a chromosome with a set chance to mutate the chromosome. An approriate value I have found is around 0.02 as this only mutates a few chromosomes. When a chromosome does get mutated, it enters the mutate_chromsome method, which retraces the steps of the chromosome until the point the mutation occurs. It then enters another for loop which generates a new path from where the mutation occured. It does this through the same process as when the initial chromosomes were created, that is via the border_check method and filling the remainder with zeros. It then returns a mutated chromosome and replaces the initial one.

* The crossover methods are made to find a common path in both chromosomes and to then swap their values from the first same number that is discovered. It creates two children by entering the child1_crossover and child2_crossover methods. It first sets a chromosome where the first value is 1, and enters two reversed loops where it tries to find the first common value between the two that isnt zero which starts at the end, and finishes at the start of the chromsome. If it does, it enters another for loop that populates the child chromosome with the values of the first parent up until the common value was found, after which it enters another for loop that populates the rest of the path with the other parent. It then returns the child chromsome when the path ends or if a value that is already in the child is found. For the corresponding crossover method the process is almost identical but with the parents swapped. The rest of the crossover function then populates the remainder of the child chromosomes with zeros. It also checks to see if the crossover resulted in a child with a higher cost function in which case it will set it equal to the parent it copied it's first numbers from. This step isn't neccesary however it does help ensure that the output will always have at worst the same cost function as the parent.

* An example of what a crossover would look like; take two parents parent1: 1, 2, 6, 5, 4, 3, 0, 0.. and parent2: 1, 4, 8, 9, 10, 0, 0... Child1 would thus be: 1, 2, 6, 5, 4, 8, 9, 10, 0, 0.. and child2 would be 1, 5, 4, 0, 0... This also shows that a child that has a lower cost function than it's parents can be created using this crossover technique. Or another example where parent1 is 1, 5, 6, 2, 0, 0... parent2 is 1, 2, 1, 0, 0. Child1 would be 1, 5, 6, 2, 1, 0, 0.. and child2 would be 1, 2, 1, 5, 6, 0, 0.. Here both children have a lower cost function than their parents. There are of course scenarios in which both children have a higher cost function than their parents, in these cases both will be dropped.

---

## Running the algorithm  **(~10%)**

*  From testing a good number for the population seems to be around 500 as it gives high success rates while not taking too long however it could be changed to other values for similar results. The generations has the same rationale. The mutation rate is set to 0.02 however this I did not set in the parameters class but rather in the mutation method. Any higher would produce varied results.
"""

class parameters:
  def __init__(self):
    self.number_in_population = 500

    self.maximum_number_of_generations = 200

    self.child_rate =0.75

    self.mutatation_rate = 0.2

def run_genetic(prob, params):

  cost_function = prob.cost_function

  number_in_population = params.number_in_population
  max_number_of_iterations = params.maximum_number_of_generations
  number_of_new_children_per_iteration = params.number_in_population*params.child_rate
  mutation_rate = params.mutatation_rate


  best_solution = individual(prob)
  best_solution.cost = 999999



  # Generate initial population
  population = []
  for x in range(number_in_population):
    new_individual = individual(prob)
    population.append(new_individual)
    if new_individual.cost < best_solution.cost:
      best_solution = deepcopy(new_individual)


  print("Lowest cost chromosome without any mutation or crossover: ", best_solution.chromosome)


  for iteration in range(max_number_of_iterations):
    # generate children
    children = []

    while len(children) < number_of_new_children_per_iteration:
      parent1_index, parent2_index = choose_two_indices_from(number_in_population)
      parent1 = population[parent1_index]
      parent2 = population[parent2_index]

      child1, child2 = individual.crossover(parent1, parent2)
      child1.potentially_mutate()
      child2.potentially_mutate()

      #cost of children
      child1.cost = cost_function(child1.chromosome)
      child2.cost = cost_function(child2.chromosome)


      # add to children list
      children.append(child1)
      children.append(child2)


    # add children to population
    population += children

    # sort the population
    population = sorted(population,key= lambda x: x.cost)
    # cull population
    population = population[:number_in_population]

    # retrieve best solution
    if population[0].cost<best_solution.cost:
      best_solution = deepcopy(population[0])




  print("Lowest cost chromosome after crossover and mutation: ", best_solution.chromosome)
  print("Lowest cost chromosome cost: ", best_solution.cost)



  return population, best_solution

def choose_two_indices_from(max_number):
  ind1 = np.random.randint(max_number)
  ind2 = np.random.randint(max_number)
  if ind1 == ind2:
    return choose_two_indices_from(max_number)

  return ind1,ind2

params = parameters()
prob = problem()

run1 = run_genetic(prob, params)
  run2 = run_genetic(prob, params)
  run3 = run_genetic(prob, params)
  run4 = run_genetic(prob, params)
  run5 = run_genetic(prob, params)

"""## Results and conclusions    **(~10%)**

* Without any mutation or crossover the solution can get roughly about 14 numbers close to the solution out of the 17 when the population is set to 10000. This is not much different compared to setting the population to 1000 showing that in order to get all 17 numbers it gets exponentially less likely without crossover or mutation. However with crossover and mutation the answer can be attained and the correct answer can be seen when the chromosome cost is 0, which is when all 17 places are filled with legal moves and it ends with 16. This shows the genetic algorithm is ideal for finding hamiltonian paths with smaller spaces at minimum. Also take notice that the path taken for mutiple of the correct final results can differ. It can start 1, 2, 1, or 1, 5, 1, it can also end up with ..14, 15, 16, or 11, 12, 16  or 11, 15, 16. All of the paths taken can easily be checked if they are a legal path by tracing it on a 4x4 grid.

* This can be further tested without any mutation or crossover to see how effective the algorithm can be without these two. For this problem they are both crucial for achieving the correct result, especially the crossover. The difference can be seen from the lowest cost initial chromosome always being lower than the lowest cost chromosome after crossover and mutation. The correct answer shows up roughly 4/5 times from when I ran it. I now need to go to sleep as I have spent far too much time on this project that is worth 30% It was a fun assignment however. And the amount of errors encountered that took hours to fix was an amount to say the least. The check_borders validation also had to be changed from the initial as I changed the chromosomes to start with 1 rather than 0 to make it easier to calculate the cost function.

## **References**
https://mathworld.wolfram.com/HamiltonianPath.html

https://www.youtube.com/watch?v=ZKh6z0X6KRw

https://colab.research.google.com/drive/1PoBnqi-BbMdtT-f29_4dogH8jbqtu3hi
"""